import type { Project } from "@shared/schema";
import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";
import { storage } from "../storage";

export interface EnvVar {
  key: string;
  value: string;
  isSecret: boolean;
  isAutoGenerated: boolean;
  description?: string;
}

// Common patterns to ignore
const IGNORED_KEYS = new Set([
  "NODE_ENV", "PUBLIC_URL", "BASE_URL", "MODE", "DEV", "PROD", "SSR"
]);

export async function detectEnvVars(project: Project): Promise<Record<string, EnvVar>> {
  if (!project.normalizedFolderPath || !fs.existsSync(project.normalizedFolderPath)) {
    return {};
  }

  const detectedKeys = new Set<string>();
  
  // Regex patterns
  const patterns = [
    /process\.env\.([A-Z_][A-Z0-9_]*)/g,
    /import\.meta\.env\.([A-Z_][A-Z0-9_]*)/g,
    /VITE_([A-Z_][A-Z0-9_]*)/g
  ];

  function walk(dir: string) {
    const items = fs.readdirSync(dir);
    for (const item of items) {
      if (item === "node_modules" || item === ".git" || item === "dist" || item === "build") continue;
      
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        walk(fullPath);
      } else if (/\.(js|jsx|ts|tsx|html|svelte|vue)$/.test(item)) {
        const content = fs.readFileSync(fullPath, "utf-8");
        
        for (const pattern of patterns) {
          let match;
          while ((match = pattern.exec(content)) !== null) {
            const key = match[1];
            if (key && !IGNORED_KEYS.has(key)) {
              detectedKeys.add(key);
            }
          }
        }
      }
    }
  }

  try {
    walk(project.normalizedFolderPath);
  } catch (e) {
    console.error("Error scanning for env vars:", e);
  }

  // Convert to EnvVar objects (without values yet)
  const result: Record<string, EnvVar> = {};
  detectedKeys.forEach(key => {
    result[key] = {
      key,
      value: "",
      isSecret: isSecretKey(key),
      isAutoGenerated: false
    };
  });

  return result;
}

function isSecretKey(key: string): boolean {
  const lower = key.toLowerCase();
  return lower.includes("secret") || 
         lower.includes("key") || 
         lower.includes("token") || 
         lower.includes("password") || 
         lower.includes("credential") ||
         lower.includes("auth");
}

function generateValue(key: string): string {
  const lower = key.toLowerCase();
  
  if (key === "PORT") return "3000";
  if (lower.includes("database_url") || lower.includes("db_url")) {
    return "postgres://user:password@localhost:5432/dbname"; // Placeholder
  }
  if (lower.includes("url") || lower.includes("uri")) {
    return "http://localhost:3000";
  }
  
  // Generate random secret
  return crypto.randomBytes(16).toString("hex");
}

export async function autoFixEnvVars(project: Project): Promise<Record<string, EnvVar>> {
  const existingVars = (project.envVars as Record<string, EnvVar>) || {};
  const detectedVars = await detectEnvVars(project);
  
  const mergedVars = { ...existingVars };
  let hasChanges = false;

  // Add missing keys with generated values
  for (const [key, detectedVar] of Object.entries(detectedVars)) {
    if (!mergedVars[key]) {
      mergedVars[key] = {
        ...detectedVar,
        value: generateValue(key),
        isAutoGenerated: true
      };
      hasChanges = true;
    }
  }

  if (hasChanges) {
    await storage.updateProject(project.id, { envVars: mergedVars });
  }

  return mergedVars;
}
