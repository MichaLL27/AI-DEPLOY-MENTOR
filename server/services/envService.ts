import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";
import { storage } from "../storage";
import type { Project } from "@shared/schema";

export interface EnvVar {
  key: string;
  value: string;
  isSecret: boolean;
  isAutoGenerated: boolean;
}

/**
 * Detect required environment variables from project source code
 */
export async function detectEnvVars(project: Project): Promise<string[]> {
  if (!project.normalizedFolderPath || !fs.existsSync(project.normalizedFolderPath)) {
    return [];
  }

  const detectedKeys = new Set<string>();
  const files = findFiles(project.normalizedFolderPath, [".js", ".ts", ".tsx", ".jsx", ".py", ".json"]);

  for (const file of files) {
    try {
      const content = fs.readFileSync(file, "utf-8");
      
      // Pattern 1: process.env.KEY
      // Relaxed regex to catch lowercase keys too
      const processEnvMatches = Array.from(content.matchAll(/process\.env\.([a-zA-Z_][a-zA-Z0-9_]*)/g));
      for (const match of processEnvMatches) {
        if (match[1] !== "NODE_ENV") {
          detectedKeys.add(match[1]);
        }
      }

      // Pattern 2: import.meta.env.KEY
      const importMetaMatches = Array.from(content.matchAll(/import\.meta\.env\.([a-zA-Z_][a-zA-Z0-9_]*)/g));
      for (const match of importMetaMatches) {
        if (match[1] !== "MODE" && match[1] !== "BASE_URL" && match[1] !== "PROD" && match[1] !== "DEV") {
          detectedKeys.add(match[1]);
        }
      }

      // Pattern 3: VITE_KEY (often used in strings or configs)
      const viteMatches = Array.from(content.matchAll(/(VITE_[a-zA-Z0-9_]+)/g));
      for (const match of viteMatches) {
        detectedKeys.add(match[1]);
      }

    } catch (e) {
      // Ignore read errors
    }
  }

  return Array.from(detectedKeys);
}

/**
 * Auto-generate missing environment variables
 */
export async function autoFixEnvVars(project: Project): Promise<EnvVar[]> {
  const detectedKeys = await detectEnvVars(project);
  
  // Safe parsing of existing env vars to handle potential malformed data
  let currentEnvVars: Record<string, EnvVar> = {};
  
  if (project.envVars && typeof project.envVars === 'object' && !Array.isArray(project.envVars)) {
    Object.entries(project.envVars).forEach(([k, v]) => {
      // Check if it matches the EnvVar interface
      if (typeof v === 'object' && v !== null && 'key' in v && 'value' in v) {
        currentEnvVars[k] = v as EnvVar;
      } else if (typeof v === 'string') {
        // Handle legacy/simple key-value format by converting to EnvVar object
        currentEnvVars[k] = {
          key: k,
          value: v,
          isSecret: false, // Assume not secret if simple string, user can change
          isAutoGenerated: false
        };
      }
    });
  }

  const newEnvVars: Record<string, EnvVar> = { ...currentEnvVars };
  let updated = false;

  for (const key of detectedKeys) {
    if (!newEnvVars[key]) {
      updated = true;
      const generatedValue = generateValueForKey(key, project);
      newEnvVars[key] = {
        key,
        value: generatedValue.value,
        isSecret: generatedValue.isSecret,
        isAutoGenerated: true
      };
    }
  }

  if (updated) {
    await storage.updateProject(project.id, {
      envVars: newEnvVars
    });
  }

  return Object.values(newEnvVars);
}

/**
 * Generate a suitable value for a given env key
 */
function generateValueForKey(key: string, project: Project): { value: string; isSecret: boolean } {
  const upperKey = key.toUpperCase();

  // 1. Secrets
  if (upperKey.includes("SECRET") || upperKey.includes("KEY") || upperKey.includes("TOKEN") || upperKey.includes("PASSWORD")) {
    return {
      value: crypto.randomBytes(32).toString("hex"),
      isSecret: true
    };
  }

  // 2. Database
  if (upperKey.includes("DATABASE_URL") || upperKey.includes("DB_URL") || upperKey.includes("MONGO_URI")) {
    // In a real app, we might provision a DB here. For now, return a placeholder or a local value.
    // If we have a provisioned DB in the project metadata, use that.
    return {
      value: `postgresql://user:password@localhost:5432/${project.name.replace(/[^a-z0-9]/g, "_")}`,
      isSecret: true
    };
  }

  // 3. Common Ports/Hosts
  if (upperKey === "PORT") return { value: "3000", isSecret: false };
  if (upperKey === "HOST") return { value: "0.0.0.0", isSecret: false };
  if (upperKey === "NODE_ENV") return { value: "production", isSecret: false };

  // 4. URLs
  if (upperKey.includes("URL") || upperKey.includes("URI")) {
    return { value: "http://localhost:3000", isSecret: false };
  }

  // Default
  return { value: "CHANGE_ME", isSecret: false };
}

/**
 * Helper to find files recursively
 */
function findFiles(dir: string, extensions: string[]): string[] {
  let results: string[] = [];
  try {
    const list = fs.readdirSync(dir);
    list.forEach(file => {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      if (stat && stat.isDirectory()) {
        if (!["node_modules", ".git", "dist", "build"].includes(file)) {
          results = results.concat(findFiles(filePath, extensions));
        }
      } else {
        if (extensions.some(ext => file.endsWith(ext))) {
          results.push(filePath);
        }
      }
    });
  } catch (e) {
    // Ignore
  }
  return results;
}
