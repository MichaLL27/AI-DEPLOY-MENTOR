



You are updating an existing full-stack project called **AI Deploy Mentor**.
Do **NOT** rebuild the whole app. Keep the current UI, routes, and logic.
Your task is to add **Neon Postgres + Render deploy integration** to the existing backend.

---

## 1. Neon Postgres integration (external DB)

The app already uses PostgreSQL. I now want to **switch it to use an external Neon database** via a standard `DATABASE_URL` environment variable.

### Requirements

1. **Database config**

   * Create or update a single database config module, for example:
     `db/database.js` or `db/index.js`.
   * Use `pg` or the existing library to connect.
   * Read the connection string from:

     ```js
     const connectionString = process.env.DATABASE_URL;
     ```
   * Assume `DATABASE_URL` is a full Neon connection string, for example:
     `postgresql://user:password@host.neon.tech/neondb?sslmode=require`
   * Make sure SSL is enabled (Neon requires SSL).

2. **Replace local/Postgres config**

   * Wherever the code currently configures Postgres, refactor it to **import this shared db module**.
   * Remove any hardcoded connection details.
   * All queries for `projects` (and other tables, if any) should go through this shared db module.

3. **README update**

   * In `README.md`, add a short “Neon setup” section:

     * Go to Neon dashboard.
     * Create a project & database.
     * Copy the connection string.
     * Set `DATABASE_URL` in the environment variables for this app.

---

## 2. Render deploy integration (real API calls)

Right now the deploy flow uses a **fake deployed URL**.
Add **optional** integration with the **Render Public API** so when env vars are set, the app triggers a real deploy.

### Data model changes

In the `projects` table and backend model, add these optional fields:

* `render_service_id` (string, nullable)
* `render_dashboard_url` (string, nullable)
* `last_deploy_id` (string, nullable)
* `last_deploy_status` (string, nullable)

Make sure the TypeScript/JS types (if any) and SQL schema are updated accordingly.

### Environment variables

Use these env vars:

* `RENDER_API_TOKEN` – Render API Bearer token
* (optional) `RENDER_BASE_URL` – default `https://api.render.com/v1`

Do **not** hardcode secrets.

### Backend logic – deployService

In `services/deployService.js` (or similar):

1. Keep the existing fake deploy logic as a fallback.

2. Add a new helper:

   ```js
   async function triggerRenderDeploy(project) { ... }
   ```

3. Behavior for `triggerRenderDeploy(project)`:

   * If `!process.env.RENDER_API_TOKEN` or `!project.render_service_id`, return `null` and let the caller fall back to the fake URL.

   * Otherwise:

     * Call Render’s public REST API using `fetch` or `axios`.
     * Use the **Trigger deploy** endpoint (POST) from Render’s docs:
       `POST https://api.render.com/v1/services/{serviceId}/deploys`

       * `Authorization: Bearer <RENDER_API_TOKEN>`
       * `Accept: application/json`
     * Parse the JSON response and capture:

       * deploy ID
       * status (if available)
     * Store `last_deploy_id` and `last_deploy_status` in the `projects` table.

   * Optionally, add a simple polling function that checks deploy status using the proper Render API endpoint for deploys and updates `last_deploy_status` until it’s `live` or `failed`.

4. Update the main `deployProject(project)` function:

   * If Render integration is properly configured, call `triggerRenderDeploy(project)` and:

     * set `status` to `"deploying"` initially;
     * when deployment succeeds, set:

       * `status = "deployed"`
       * `deployedUrl = project.render_dashboard_url` or the URL returned by Render if available.
   * If Render integration is not configured, keep the existing behavior of using a fake URL.

### API / UI adjustments

1. In the backend `POST /api/projects` handler:

   * Allow optional fields in the request body:

     ```json
     {
       "name": "My App",
       "sourceType": "github",
       "sourceValue": "https://github.com/user/repo",
       "renderServiceId": "srv-xxxx",          // optional
       "renderDashboardUrl": "https://dash..." // optional
     }
     ```
   * Save these into `render_service_id` and `render_dashboard_url`.

2. In the frontend “Register New Project” modal:

   * Under the existing fields, add an **Advanced (optional)** section:

     * Input for “Render Service ID”
     * Input for “Render Dashboard URL”
   * These should be optional and only used when the user already has a Render service.

3. In the project detail view and/or list:

   * Show `last_deploy_status` if available.
   * `View Live` button should prefer the real `deployedUrl` if it comes from Render.

---

## 3. Code quality & safety

* Do **not** break existing endpoints or UI.
* If Render or Neon config is missing, the app should still work with the existing behavior (in-memory/fake deploys) and log a clear warning.
* Add comments in the code where developers should plug in more advanced behavior later.

---

When you’re done, make sure:

* The app starts without errors.
* Creating a project still works.
* Deploying a project:

  * uses Render if `RENDER_API_TOKEN` and `render_service_id` are set,
  * otherwise falls back to the fake deploy URL.

---
 